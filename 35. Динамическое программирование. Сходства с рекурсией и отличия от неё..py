"""
Рассмотрим сравнение динамического программирования с рекурсивными решениями вычисления чисел Фибоначчи.
Для тех, кто забыл, в одну строчку это решение можно записать так:
"""

fib = lambda n: fib(n - 1) + fib(n - 2) if n > 2 else 1

"""
Это решение неплохое, но время выполнения здесь растет экспоненциально, асимптотическая сложность оценивается как 2^n.
Человек, имея рядом листочек и ручку (и норм голову), решит эту задачу гораздо быстрее.
Он решает эту задачу от простого к сложному, т.е. рассчитывает число для более маленьких чисел, а потом идет к большим.
В этом состоит и динамическое программирование: от простого к сложному.

Теперь рассмотрим решение нашей задачи именно динамическим программированием. Нахождение числа Фибонначи будет выглядеть
так:
"""

def fib(n):
    F = [0, 1] + [0]*(n - 1) #создается список необходимого размера, начинающийся 0 и 1 (бронируется место)
    for i in range(2, n + 1): #находятся все числа Фибоначчи со 2 и заканчивая n
        F[i] = F[i - 1] + F[i - 2] #используем рекуррентную формулу
        return F[n]

"""
Это решение лучше, чем рекурсивное.
Как оно работает?
При каждом вызове рекурсивной функции на стек кладется текущий номер числа и адрес возврата.
Поэтому нужная память здесь - 2n.
"""